import java.math.BigDecimal;
import java.math.MathContext;
import java.util.Arrays;


public class PalindromePermutations
{
	public double palindromeProbability(String word)
	{
	
	    int[] letters = new int['z' - 'a' + 1];
	    
	    char[] cA = word.toCharArray();
	    int N = word.length(); 
	    for (char c : cA) {
	        letters[c - 'a']++;
	    }
	    int base = -1; 
	    for (int i = 0; i <= 'z' - 'a'; i++) {
	        if (letters[i] %2 != 0) {
	            if (base != -1 || N %2 == 0) {
	                return 0;
	            }
	            base = i;
	        }
	    }
	    
	    if (base != -1 && letters[base] == N) {
	        return 1;
	    }
	    BigDecimal[] dec = new BigDecimal[N + 1];
	    dec[0] = BigDecimal.ONE;
	    for (int i = 1; i <= N; i++) {
	        dec [i]= dec[i - 1].multiply(new BigDecimal(i));
	    }
	    
	    BigDecimal probability = BigDecimal.ONE;
	    int sum = 0; 
	    int Last = N % 2 == 0 ? N : N - 1;
	    //int Last = N ;
	    for (int i = 0; i <= 'z' - 'a'; i++) {
	        int tmp = letters[i];
	        while (tmp >= 1) {

	            BigDecimal roop = new BigDecimal(tmp - 1).divide(new BigDecimal(Last - 1), MathContext.DECIMAL128);
	            sum += calc(N, letters[i]);
	            System.out.println("roop " + roop );
	            probability = probability.multiply(roop, MathContext.DECIMAL128);
	            Last -=2;
	            tmp -=2;
//	            probability = probability.multiply(tmp.divide(dec[Last - 1], MathContext.DECIMAL128));
	        } 
	    }
	    return probability.doubleValue();
	    //return (double) sum / dec[N].doubleValue();
	}
	static int calc(int cnt, int elem) {
	    int res = 1;
	    if (elem % 2 == 0) {
     	    for (int i = 0; i < elem / 2; i++) {
	            res *= (cnt - 1);
	        }
	    } else {
	        for (int i = 0; i < elem / 2; i++) {
	            res *= (cnt - 1);
	        }
	        
	    }
	    return res;
	}
	static class Pascal {
	    static BigDecimal[][] probability = new BigDecimal[50][50];
	    
	    static {
	       //probability[0] = new double[1]l;
	        for (int i = 0; i < probability.length; i++) {
	            Arrays.fill(probability[i], BigDecimal.ZERO);
	        }
	       probability[0][0] = BigDecimal.ONE;
	       for (int i = 1; i < probability.length; i++) {
	          //probability[i] = new double[i + 1];
	          probability[i][0] = BigDecimal.ONE;
	          probability[i][i] = BigDecimal.ONE;
	          for (int j = 1; j < i ; j++) {
	              probability[i][j] = probability[i - 1][j - 1].add(probability[i - 1][j]);
	          }
	       }
	        
	    }
	    
	    static BigDecimal calc(int cnt, int pCnt) {
	        BigDecimal allCnt = new BigDecimal(2).pow(cnt); 
	        BigDecimal elementCnt = probability[cnt][pCnt]; 
	        BigDecimal p = elementCnt.divide(allCnt, MathContext.DECIMAL128);
	        return p;
	    }
	}
	
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit-pf 2.3.0
	private static boolean KawigiEdit_RunTest(int testNum, String p0, boolean hasAnswer, double p1) {
		System.out.print("Test " + testNum + ": [" + "\"" + p0 + "\"");
		System.out.println("]");
		PalindromePermutations obj;
		double answer;
		obj = new PalindromePermutations();
		long startTime = System.currentTimeMillis();
		answer = obj.palindromeProbability(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			res = answer == answer && Math.abs(p1 - answer) <= 1e-9 * Math.max(1.0, Math.abs(p1));
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
			if (hasAnswer) {
				System.out.println("Desired answer:");
				System.out.println("\t" + p1);
			}
			System.out.println("Your answer:");
			System.out.println("\t" + answer);
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		boolean disabled;
		boolean tests_disabled;
		all_right = true;
		tests_disabled = false;
		
		String p0;
		double p1;
		
		// ----- test 0 -----
		disabled = false;
		p0 = "haha";
		p1 = 0.3333333333333333D;
		all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 1 -----
		disabled = false;
		p0 = "xxxxy";
		p1 = 0.2D;
		all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 2 -----
		disabled = false;
		p0 = "xxxx";
		p1 = 1.0D;
		all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 3 -----
		disabled = false;
		p0 = "abcde";
		p1 = 0.0D;
		all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 4 -----
		disabled = false;
		p0 = "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhff";
		p1 = 0.025641025641025637D;
		all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		if (all_right) {
			if (tests_disabled) {
				System.out.println("You're a stud (but some test cases were disabled)!");
			} else {
				System.out.println("You're a stud (at least on given cases)!");
			}
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// A palindrome is a word that reads the same forwards and backwards. For example, "a", "abba", and "zzz" are palindromes, while "ab" and "xxxyx" are not.
	// 
	// The anagram of a string S is any string we can obtain from S by rearranging its letters. For example, the string "haha" has exactly six anagrams: "aahh", "ahah", "ahha", "haah", "haha", and "hhaa".
	// 
	// We are given a String word. We will choose one of its anagrams uniformly at random. Return the probability that the chosen anagram will be a palindrome.
	// 
	// DEFINITION
	// Class:PalindromePermutations
	// Method:palindromeProbability
	// Parameters:String
	// Returns:double
	// Method signature:double palindromeProbability(String word)
	// 
	// 
	// NOTES
	// -The returned value must have an absolute or a relative error of less than 1e-9.
	// 
	// 
	// CONSTRAINTS
	// -word will contain between 1 and 50 characters, inclusive.
	// -Each character of word will be a lowercase English letter ('a'-'z').
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// "haha"
	// 
	// Returns: 0.3333333333333333
	// 
	// Each of the six anagrams of "haha" will be selected with probability 1/6.
	// Two of them are palindromes: "ahha" and "haah".
	// Hence, the probability of selecting a palindrome is 2/6.
	// 
	// 1)
	// "xxxxy"
	// 
	// Returns: 0.2
	// 
	// 
	// 
	// 2)
	// "xxxx"
	// 
	// Returns: 1.0
	// 
	// This word only has one anagram: "xxxx". That is a palindrome.
	// 
	// 3)
	// "abcde"
	// 
	// Returns: 0.0
	// 
	// Regardless of how we rearrange the letters of "abcde", we will never get a palindrome.
	// 
	// 4)
	// "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhff"
	// 
	// Returns: 0.025641025641025637
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}

//Powered by KawigiEdit-pf 2.3.0!
